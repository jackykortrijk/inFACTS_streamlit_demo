<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Operations Flow Visualization</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script>
        // Operations will be injected here by Streamlit
        /*__OPERATIONS_PLACEHOLDER__*/

        // Scene setup (2D)
        const scene = new THREE.Scene();
        let width = window.innerWidth;
        let height = window.innerHeight;
        let aspect = width / height;
        let camera, viewSize;

        function createCamera(numNodes) {
            aspect = window.innerWidth / window.innerHeight;
            // Calculate view size so all nodes fit with margin
            const spacing = 3;
            const margin = 2;
            const totalWidth = (numNodes - 1) * spacing + margin * 2;
            viewSize = Math.max(10, totalWidth / aspect);
            camera = new THREE.OrthographicCamera(
                -totalWidth / 2, totalWidth / 2,
                viewSize / 2, -viewSize / 2,
                0.1, 1000
            );
            camera.position.set(0, 0, 20);
            camera.lookAt(0, 0, 0);
        }

        // Initial camera
        createCamera(operations.length);

        const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setClearColor(0xffffff, 0); // transparent background
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);

        // Node geometry/material
        const nodeGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const nodeMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff });
        const bufferMaterial = new THREE.MeshStandardMaterial({ color: 0xffbb00 });
        const sourceMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });

        let nodeMeshes = [];
        let labelSprites = [];
        let lines = [];
        const spacing = 3;

        function clearScene() {
            nodeMeshes.forEach(mesh => scene.remove(mesh));
            nodeMeshes = [];
            lines.forEach(line => scene.remove(line));
            lines = [];
            labelSprites.forEach(sprite => scene.remove(sprite));
            labelSprites = [];
        }

        function makeTextSprite(message) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = '16px Arial';
            const textWidth = context.measureText(message).width;
            canvas.width = textWidth + 16;
            canvas.height = 32;
            context.font = '16px Arial';
            context.fillStyle = 'rgba(255,255,255,0.9)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#222';
            context.fillText(message, 8, 22);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width/32, 1, 1);
            return sprite;
        }

        function renderFlow(ops) {
            clearScene();
            createCamera(ops.length);
            const spacing = 3;
            ops.forEach((op, i) => {
                let mat = nodeMaterial;
                if (op.name && op.name.toLowerCase().startsWith('buffer')) mat = bufferMaterial;
                if (op.name && op.name.toLowerCase() === 'source') mat = sourceMaterial;
                const mesh = new THREE.Mesh(nodeGeometry, mat);
                mesh.position.x = i * spacing - ((ops.length - 1) * spacing) / 2;
                mesh.position.y = 0;
                mesh.position.z = 0;
                scene.add(mesh);
                nodeMeshes.push(mesh);

                // Add label as sprite
                const label = makeTextSprite(op.name || '');
                label.position.set(mesh.position.x, mesh.position.y + 1, mesh.position.z);
                scene.add(label);
                labelSprites.push(label);
            });
            // Draw lines between nodes
            for (let i = 0; i < nodeMeshes.length - 1; i++) {
                const material = new THREE.LineBasicMaterial({ color: 0x222222 });
                const points = [];
                points.push(nodeMeshes[i].position);
                points.push(nodeMeshes[i+1].position);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                lines.push(line);
            }
        }

        // Initial render
        renderFlow(operations);

        // Animate
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Responsive resize
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            aspect = width / height;
            createCamera(nodeMeshes.length);
            renderer.setSize(width, height);
        });

        // Expose a function for dynamic update (if Streamlit reloads iframe)
        window.updateOperationsFlow = function(newOps) {
            renderFlow(newOps);
        }
    </script>
</body>
</html>
