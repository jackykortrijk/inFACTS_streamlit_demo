<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Operations Flow Visualization</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script>
        // Operations will be injected here by Streamlit

    /*__OPERATIONS_PLACEHOLDER__*/

        // Scene setup (2D)
        const scene = new THREE.Scene();
        let width = window.innerWidth;
        let height = window.innerHeight;
        let aspect = width / height;
        let camera, viewSize;

        function createCamera(numNodes) {
            aspect = window.innerWidth / window.innerHeight;
            // Calculate view size so all nodes fit with margin
            const spacing = 3;
            const margin = 2;
            const totalWidth = (numNodes - 1) * spacing + margin * 2;
            viewSize = Math.max(10, totalWidth / aspect);
            camera = new THREE.OrthographicCamera(
                -totalWidth / 2, totalWidth / 2,
                viewSize / 2, -viewSize / 2,
                0.1, 1000
            );
            camera.position.set(0, 0, 20);
            camera.lookAt(0, 0, 0);
        }

        // Initial camera
        createCamera(operations.length);

        const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setClearColor(0xffffff, 0); // transparent background
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);

        // Node geometry/material
        const nodeGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const nodeMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff });
        const bufferMaterial = new THREE.MeshStandardMaterial({ color: 0xffbb00 });
        const sourceMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });

        let nodeMeshes = [];
        let labelSprites = [];
        let lines = [];
        const spacing = 3;

        function clearScene() {
            nodeMeshes.forEach(mesh => scene.remove(mesh));
            nodeMeshes = [];
            lines.forEach(line => scene.remove(line));
            lines = [];
            labelSprites.forEach(sprite => scene.remove(sprite));
            labelSprites = [];
        }

        function makeTextSprite(message) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = '16px Arial';
            const textWidth = context.measureText(message).width;
            canvas.width = textWidth + 16;
            canvas.height = 32;
            context.font = '16px Arial';
            context.fillStyle = 'rgba(255,255,255,0.9)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#222';
            context.fillText(message, 8, 22);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width/32, 1, 1);
            return sprite;
        }

        function renderFlow(ops) {
            clearScene();
            // Add a Sink node at the end
            const allOps = [...ops, { name: 'Sink' }];
            createCamera(allOps.length);
            const spacing = 3;
            allOps.forEach((op, i) => {
                let mat = nodeMaterial;
                if (op.name && op.name.toLowerCase().startsWith('buffer')) mat = bufferMaterial;
                if (op.name && op.name.toLowerCase() === 'source') mat = sourceMaterial;
                if (op.name && op.name.toLowerCase() === 'sink') mat = new THREE.MeshStandardMaterial({ color: 0xff3333 });
                const mesh = new THREE.Mesh(nodeGeometry, mat);
                mesh.position.x = i * spacing - ((allOps.length - 1) * spacing) / 2;
                mesh.position.y = 0;
                mesh.position.z = 0;
                scene.add(mesh);
                nodeMeshes.push(mesh);

                // Add label as sprite
                const label = makeTextSprite(op.name || '');
                label.position.set(mesh.position.x, mesh.position.y + 1, mesh.position.z);
                scene.add(label);
                labelSprites.push(label);
            });
            // Draw arrows between nodes
            for (let i = 0; i < nodeMeshes.length - 1; i++) {
                const from = nodeMeshes[i].position;
                const to = nodeMeshes[i+1].position;
                // Node radius (should match sphere geometry radius)
                const nodeRadius = 0.5;
                // Direction vector
                const dir = new THREE.Vector3().subVectors(to, from).normalize();
                // Shorten the shaft so the arrow tip is just before the next node
                const shaftEnd = to.clone().add(dir.clone().multiplyScalar(-nodeRadius - 0.05));
                const shaftStart = from.clone().add(dir.clone().multiplyScalar(nodeRadius + 0.05));
                // Draw arrow shaft
                const shaftMaterial = new THREE.LineBasicMaterial({ color: 0x222222 });
                const shaftPoints = [shaftStart, shaftEnd];
                const shaftGeometry = new THREE.BufferGeometry().setFromPoints(shaftPoints);
                const shaft = new THREE.Line(shaftGeometry, shaftMaterial);
                scene.add(shaft);
                lines.push(shaft);
                // Draw arrow head
                const arrowLength = 0.7;
                const arrowWidth = 0.3;
                // Arrow base at the end of the shaft
                const arrowBase = shaftEnd;
                // Perpendicular direction (in XY plane)
                const perp = new THREE.Vector3(-dir.y, dir.x, 0).normalize();
                const left = arrowBase.clone().add(perp.clone().multiplyScalar(arrowWidth));
                const right = arrowBase.clone().add(perp.clone().multiplyScalar(-arrowWidth));
                // Arrow tip a bit before the node center
                const tip = to.clone().add(dir.clone().multiplyScalar(-nodeRadius + 0.05));
                // Draw two lines for the arrow head
                const arrowHeadMaterial = new THREE.LineBasicMaterial({ color: 0x222222 });
                const leftHeadGeometry = new THREE.BufferGeometry().setFromPoints([left, tip]);
                const rightHeadGeometry = new THREE.BufferGeometry().setFromPoints([right, tip]);
                const leftHead = new THREE.Line(leftHeadGeometry, arrowHeadMaterial);
                const rightHead = new THREE.Line(rightHeadGeometry, arrowHeadMaterial);
                scene.add(leftHead);
                scene.add(rightHead);
                lines.push(leftHead);
                lines.push(rightHead);
            }
        }

        // Initial render
        renderFlow(operations);

        // Animate
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Responsive resize
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            aspect = width / height;
            createCamera(nodeMeshes.length);
            renderer.setSize(width, height);
        });

        // Expose a function for dynamic update (if Streamlit reloads iframe)
        window.updateOperationsFlow = function(newOps) {
            renderFlow(newOps);
        }
    </script>
</body>
</html>
