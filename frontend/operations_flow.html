<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Operations Flow Visualization</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script>
        // Operations will be injected here by Streamlit
        /*__OPERATIONS_PLACEHOLDER__*/

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setClearColor(0xffffff, 0); // transparent background
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);

        // Node geometry/material
        const nodeGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const nodeMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff });
        const bufferMaterial = new THREE.MeshStandardMaterial({ color: 0xffbb00 });
        const sourceMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });

        let nodeMeshes = [];
        let labelSprites = [];
        let lines = [];
        const spacing = 3;

        function clearScene() {
            nodeMeshes.forEach(mesh => scene.remove(mesh));
            nodeMeshes = [];
            lines.forEach(line => scene.remove(line));
            lines = [];
            labelSprites.forEach(sprite => scene.remove(sprite));
            labelSprites = [];
        }

        function makeTextSprite(message) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = '16px Arial';
            const textWidth = context.measureText(message).width;
            canvas.width = textWidth + 16;
            canvas.height = 32;
            context.font = '16px Arial';
            context.fillStyle = 'rgba(255,255,255,0.9)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#222';
            context.fillText(message, 8, 22);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width/32, 1, 1);
            return sprite;
        }

        function renderFlow(ops) {
            clearScene();
            ops.forEach((op, i) => {
                let mat = nodeMaterial;
                if (op.name && op.name.toLowerCase().startsWith('buffer')) mat = bufferMaterial;
                if (op.name && op.name.toLowerCase() === 'source') mat = sourceMaterial;
                const mesh = new THREE.Mesh(nodeGeometry, mat);
                mesh.position.x = i * spacing;
                scene.add(mesh);
                nodeMeshes.push(mesh);

                // Add label as sprite
                const label = makeTextSprite(op.name || '');
                label.position.set(mesh.position.x, mesh.position.y + 1, mesh.position.z);
                scene.add(label);
                labelSprites.push(label);
            });
            // Draw lines between nodes
            for (let i = 0; i < nodeMeshes.length - 1; i++) {
                const material = new THREE.LineBasicMaterial({ color: 0x222222 });
                const points = [];
                points.push(nodeMeshes[i].position);
                points.push(nodeMeshes[i+1].position);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                lines.push(line);
            }
            // Camera setup
            camera.position.z = Math.max(8, ops.length * 1.5);
            camera.position.y = 2;
            camera.lookAt(new THREE.Vector3(ops.length * spacing / 2, 0, 0));
        }

        // Initial render
        renderFlow(operations);

        // Animate
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Responsive resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Expose a function for dynamic update (if Streamlit reloads iframe)
        window.updateOperationsFlow = function(newOps) {
            renderFlow(newOps);
        }
    </script>
</body>
</html>
