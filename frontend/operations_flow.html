<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Operations Flow Visualization</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script>
        // Operations will be injected here by Streamlit
        /*__OPERATIONS_PLACEHOLDER__*/

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setClearColor(0xffffff, 0); // transparent background
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);

        // Node geometry/material
    // Larger, higher-res nodes
    const nodeGeometry = new THREE.SphereGeometry(1.1, 64, 64);
    const nodeMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff, roughness: 0.3, metalness: 0.5 });
    const bufferMaterial = new THREE.MeshStandardMaterial({ color: 0xffbb00, roughness: 0.3, metalness: 0.5 });
    const sourceMaterial = new THREE.MeshStandardMaterial({ color: 0x00cc44, roughness: 0.3, metalness: 0.5 });

        let nodeMeshes = [];
        let labelSprites = [];
        let lines = [];
        const spacing = 3;

        function clearScene() {
            nodeMeshes.forEach(mesh => scene.remove(mesh));
            nodeMeshes = [];
            lines.forEach(line => scene.remove(line));
            lines = [];
            labelSprites.forEach(sprite => scene.remove(sprite));
            labelSprites = [];
        }

        function makeTextSprite(message) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = 'bold 22px Arial';
            const textWidth = context.measureText(message).width;
            canvas.width = textWidth + 32;
            canvas.height = 48;
            context.font = 'bold 22px Arial';
            // Draw white rounded rect background
            context.fillStyle = 'rgba(255,255,255,0.95)';
            context.beginPath();
            context.moveTo(8, 0);
            context.lineTo(canvas.width-8, 0);
            context.quadraticCurveTo(canvas.width, 0, canvas.width, 8);
            context.lineTo(canvas.width, canvas.height-8);
            context.quadraticCurveTo(canvas.width, canvas.height, canvas.width-8, canvas.height);
            context.lineTo(8, canvas.height);
            context.quadraticCurveTo(0, canvas.height, 0, canvas.height-8);
            context.lineTo(0, 8);
            context.quadraticCurveTo(0, 0, 8, 0);
            context.closePath();
            context.fill();
            // Draw text
            context.fillStyle = '#222';
            context.textBaseline = 'middle';
            context.fillText(message, 16, canvas.height/2);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width/20, 2.2, 1);
            return sprite;
        }
            // Add outline to node
            const outlineGeom = new THREE.SphereGeometry(1.18, 64, 64);
            const outlineMat = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.BackSide });
            const outline = new THREE.Mesh(outlineGeom, outlineMat);
            outline.position.copy(mesh.position);
            mesh.add(outline);

        function renderFlow(ops) {
            clearScene();
            ops.forEach((op, i) => {
                let mat = nodeMaterial;
                if (op.name && op.name.toLowerCase().startsWith('buffer')) mat = bufferMaterial;
                if (op.name && op.name.toLowerCase() === 'source') mat = sourceMaterial;
                const mesh = new THREE.Mesh(nodeGeometry, mat);
                mesh.position.x = i * spacing;
                scene.add(mesh);
                nodeMeshes.push(mesh);

                // Add label as sprite
                const label = makeTextSprite(op.name || '');
                label.position.set(mesh.position.x, mesh.position.y + 1, mesh.position.z);
                scene.add(label);
                labelSprites.push(label);
            });
            // Draw lines between nodes
            for (let i = 0; i < nodeMeshes.length - 1; i++) {
                const material = new THREE.LineBasicMaterial({ color: 0x222222 });
                const points = [];
                points.push(nodeMeshes[i].position);
                points.push(nodeMeshes[i+1].position);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                lines.push(line);
            }
            // Camera setup
            camera.position.z = Math.max(8, ops.length * 1.5);
            camera.position.y = 2;
            camera.lookAt(new THREE.Vector3(ops.length * spacing / 2, 0, 0));
        }

        // Initial render
        renderFlow(operations);

        // Animate
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Responsive resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Expose a function for dynamic update (if Streamlit reloads iframe)
        window.updateOperationsFlow = function(newOps) {
            renderFlow(newOps);
        }
    </script>
</body>
</html>
